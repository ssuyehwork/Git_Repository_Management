# é¡¹ç›®ä»£ç æ±‡æ€»

ç”Ÿæˆæ—¶é—´: 2025-12-18 14:25:24
æ–‡ä»¶æ€»æ•°: 19

---

## æ–‡ä»¶: T åŒæ­¥è¦†ç›–å·¥å…· - è‡ªåŠ¨è§£å‹ç‰ˆ.py

```python
ï»¿# -*- coding: utf-8 -*-
# main.py
import sys
import time
from PySide6.QtWidgets import QApplication
from app.core.instance_lock import SingleInstanceManager
from app.ui.main_window import MainWindow

def main():
    app = QApplication(sys.argv)

    # å•å®ä¾‹æ§åˆ¶
    instance_manager = SingleInstanceManager(on_exit_callback=app.quit)
    is_first = instance_manager.try_start_server()

    if not is_first:
        SingleInstanceManager.notify_existing_instance_to_exit()
        time.sleep(0.5)
        # å†æ¬¡å°è¯•æŠ¢å ï¼ˆåä¾‹æ¥ç®¡æ¨¡å¼ï¼‰
        instance_manager.try_start_server()

    window = MainWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
```

## æ–‡ä»¶: app\__init__.py

```python
ï»¿# -*- coding: utf-8 -*-
```

## æ–‡ä»¶: app\config\constants.py

```python
# -*- coding: utf-8 -*-
# app/config/constants.py
import os

# ç½‘ç»œé…ç½®
SINGLE_INSTANCE_HOST = "127.0.0.1"
SINGLE_INSTANCE_PORT = 54321

# æ–‡ä»¶è·¯å¾„é…ç½®
CONFIG_FILE = "path_groups.json"
HISTORY_FILE = "processed_files.json"
MAIN_PROGRAM_FILE = "main_program_path.json"
WINDOW_SIZE_FILE = "window_size.json"
LAST_SELECTED_GROUP_FILE = "last_selected_group.json"
LAST_SOURCE_FOLDER_FILE = "last_source_folder.json"
LAST_EXTRACT_PATH_FILE = "last_extract_path.json"

# é»˜è®¤æ–‡ä»¶å¤¹è·¯å¾„ (Windows ç¯å¢ƒ)
USER_HOME = os.path.expanduser("~")
DOWNLOAD_FOLDER = os.path.join(USER_HOME, "Downloads")

# é¢œè‰²é…ç½®
COLOR_ERROR_BG = "#8b0000"
COLOR_ERROR_FG = "#ffffff"
```

## æ–‡ä»¶: app\config\__init__.py

```python
ï»¿# -*- coding: utf-8 -*-
```

## æ–‡ä»¶: app\core\file_manager.py

```python
ï»¿# app/core/file_manager.py
import os
import re
import shutil
import zipfile
from app.config import constants

class FileManager:
    @staticmethod
    def scan_zip_files(folder):
        """æ‰«æç¬¦åˆæ¡ä»¶çš„å‹ç¼©æ–‡ä»¶"""
        if not os.path.exists(folder):
            return []
        zip_files = []
        try:
            for filename in os.listdir(folder):
                if "jules_" in filename and filename.endswith(".zip"):
                    full_path = os.path.join(folder, filename)
                    if os.path.isfile(full_path):
                        zip_files.append(full_path)
        except Exception:
            pass
        return zip_files

    @staticmethod
    def get_next_jules_number(extract_base):
        """è·å–ä¸‹ä¸€ä¸ªæ–‡ä»¶å¤¹åºå·"""
        if not os.path.exists(extract_base):
            return 1
        max_num = 0
        try:
            for item in os.listdir(extract_base):
                if os.path.isdir(os.path.join(extract_base, item)):
                    match = re.match(r"jules_(\d+)", item)
                    if match:
                        num = int(match.group(1))
                        max_num = max(max_num, num)
        except Exception:
            pass
        return max_num + 1

    @staticmethod
    def extract_zip(zip_path, extract_to):
        """è§£å‹å¹¶è¿”å›æ–‡ä»¶åˆ—è¡¨"""
        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                file_list = zip_ref.namelist()
                zip_ref.extractall(extract_to)
            return True, file_list
        except Exception as e:
            return False, str(e)

    @staticmethod
    def copy_files_recursive(source, target):
        """é€’å½’è¦†ç›–å¤åˆ¶æ–‡ä»¶"""
        count = 0
        errors = []
        for root_dir, dirs, files in os.walk(source):
            for file in files:
                try:
                    src_file = os.path.join(root_dir, file)
                    rel_path = os.path.relpath(src_file, source)
                    dst_file = os.path.join(target, rel_path)
                    os.makedirs(os.path.dirname(dst_file), exist_ok=True)
                    shutil.copy2(src_file, dst_file)
                    count += 1
                except Exception as e:
                    errors.append((os.path.relpath(os.path.join(root_dir, file), source), str(e)))
        return count, errors

    @staticmethod
    def get_adjacent_folder(current_path, direction='prev'):
        """
        è·å–ä¸Šä¸€ä¸ªæˆ–ä¸‹ä¸€ä¸ªç‰ˆæœ¬æ–‡ä»¶å¤¹
        :param current_path: å½“å‰é€‰ä¸­çš„è·¯å¾„
        :param direction: 'prev' æˆ– 'next'
        :return: æ–°è·¯å¾„ æˆ– None
        """
        base_dir = constants.EXTRACT_BASE
        if not os.path.exists(base_dir):
            return None

        # 1. æ‰«ææ‰€æœ‰ jules_N æ–‡ä»¶å¤¹å¹¶æŒ‰æ•°å­—æ’åº
        folders = []
        try:
            for item in os.listdir(base_dir):
                full_path = os.path.join(base_dir, item)
                if os.path.isdir(full_path):
                    match = re.match(r"jules_(\d+)", item)
                    if match:
                        num = int(match.group(1))
                        folders.append((num, full_path))
        except Exception:
            return None

        # æŒ‰åºå·ä»å°åˆ°å¤§æ’åº
        folders.sort(key=lambda x: x[0])
        
        if not folders:
            return None

        # 2. æ‰¾åˆ°å½“å‰è·¯å¾„çš„ç´¢å¼•
        current_idx = -1
        # æ ‡å‡†åŒ–è·¯å¾„åˆ†éš”ç¬¦ä»¥æ¯”è¾ƒ
        norm_current = os.path.normpath(current_path) if current_path else ""
        
        for i, (_, path) in enumerate(folders):
            if os.path.normpath(path) == norm_current:
                current_idx = i
                break
        
        # 3. è®¡ç®—ç›®æ ‡ç´¢å¼•
        target_idx = -1
        
        if current_idx == -1:
            # å¦‚æœå½“å‰è·¯å¾„ä¸åœ¨åˆ—è¡¨ä¸­ï¼Œé»˜è®¤é€‰ä¸­æœ€æ–°çš„
            target_idx = len(folders) - 1
        else:
            if direction == 'prev':
                target_idx = current_idx - 1
            else:
                target_idx = current_idx + 1

        # 4. è¾¹ç•Œæ£€æŸ¥
        if 0 <= target_idx < len(folders):
            return folders[target_idx][1]
        
        return None
```

## æ–‡ä»¶: app\core\instance_lock.py

```python
ï»¿# -*- coding: utf-8 -*-
# app/core/instance_lock.py
import socket
import threading
from app.config import constants

class SingleInstanceManager:
    def __init__(self, on_exit_callback=None):
        self.host = constants.SINGLE_INSTANCE_HOST
        self.port = constants.SINGLE_INSTANCE_PORT
        self.on_exit_callback = on_exit_callback
        self.server_socket = None
        self.thread = None

    def try_start_server(self):
        """å°è¯•ç»‘å®šç«¯å£ï¼ŒæˆåŠŸåˆ™ä¸ºä¸»å®ä¾‹"""
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        try:
            s.bind((self.host, self.port))
            s.listen(1)
        except OSError:
            s.close()
            return False

        self.server_socket = s
        self.thread = threading.Thread(target=self._server_loop, daemon=True)
        self.thread.start()
        return True

    def _server_loop(self):
        """ç›‘å¬é€€å‡ºæŒ‡ä»¤"""
        while True:
            try:
                conn, _ = self.server_socket.accept()
            except OSError:
                break
            try:
                data = conn.recv(1024)
                if not data:
                    conn.close()
                    continue
                cmd = data.decode("utf-8", errors="ignore").strip()
                if cmd == "EXIT":
                    if self.on_exit_callback:
                        self.on_exit_callback()
                    conn.close()
                    break
            except Exception:
                conn.close()
                break
        try:
            self.server_socket.close()
        except Exception:
            pass

    @classmethod
    def notify_existing_instance_to_exit(cls, timeout=1.0):
        """é€šçŸ¥æ—§å®ä¾‹é€€å‡º"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(timeout)
            s.connect((constants.SINGLE_INSTANCE_HOST, constants.SINGLE_INSTANCE_PORT))
            s.sendall(b"EXIT")
            s.close()
        except Exception:
            pass
```

## æ–‡ä»¶: app\core\process_runner.py

```python
ï»¿# -*- coding: utf-8 -*-
# app/core/process_runner.py
import os
import sys
import subprocess

class ProcessRunner:
    @staticmethod
    def prepare_command(program_path):
        """æ ¹æ®æ–‡ä»¶ç±»å‹å‡†å¤‡å¯åŠ¨å‘½ä»¤"""
        if not os.path.exists(program_path):
            raise FileNotFoundError(f"ä¸»ç¨‹åºä¸å­˜åœ¨: {program_path}")

        work_dir = os.path.dirname(program_path)
        _, ext = os.path.splitext(program_path)
        ext = ext.lower()

        cmd = []
        
        if ext == '.py':
            cmd = [sys.executable, '-u', program_path]
        elif ext == '.pyw':
            pyw_exe = sys.executable.replace("python.exe", "pythonw.exe")
            if os.path.exists(pyw_exe):
                cmd = [pyw_exe, '-u', program_path]
            else:
                cmd = [sys.executable, '-u', program_path]
        else:
            # .exe, .bat, .cmd ç­‰
            cmd = [program_path]
            
        return cmd, work_dir

    @staticmethod
    def create_process(cmd, work_dir):
        """åˆ›å»ºå­è¿›ç¨‹å¯¹è±¡ï¼ˆå¸¦ç®¡é“é‡å®šå‘ï¼‰"""
        startupinfo = None
        if os.name == 'nt':
            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = subprocess.SW_HIDE

        process = subprocess.Popen(
            cmd,
            cwd=work_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            stdin=subprocess.DEVNULL,
            text=True,
            bufsize=1,
            encoding='utf-8',
            errors='replace',
            startupinfo=startupinfo
        )
        return process
```

## æ–‡ä»¶: app\core\__init__.py

```python
ï»¿# -*- coding: utf-8 -*-
```

## æ–‡ä»¶: app\data\storage.py

```python
# -*- coding: utf-8 -*-
# app/data/storage.py
import json
import os
from app.config import constants

class JsonStorage:
    """é€šç”¨ JSON å­˜å–ç±»"""
    
    @staticmethod
    def _load(filepath, default_value):
        if not os.path.exists(filepath):
            return default_value
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return default_value

    @staticmethod
    def _save(filepath, data):
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=4, ensure_ascii=False)
        except Exception:
            pass

    # --- å…·ä½“ä¸šåŠ¡å­˜å‚¨ ---

    @classmethod
    def load_groups(cls):
        return cls._load(constants.CONFIG_FILE, {})

    @classmethod
    def save_groups(cls, groups):
        cls._save(constants.CONFIG_FILE, groups)

    @classmethod
    def load_history(cls):
        return cls._load(constants.HISTORY_FILE, [])

    @classmethod
    def save_history(cls, history):
        cls._save(constants.HISTORY_FILE, history)

    @classmethod
    def load_main_program_path(cls):
        data = cls._load(constants.MAIN_PROGRAM_FILE, {})
        return data.get("path", "")

    @classmethod
    def save_main_program_path(cls, path):
        cls._save(constants.MAIN_PROGRAM_FILE, {"path": path})

    @classmethod
    def load_window_size(cls):
        return cls._load(constants.WINDOW_SIZE_FILE, None)

    @classmethod
    def save_window_size(cls, width, height):
        cls._save(constants.WINDOW_SIZE_FILE, {"width": width, "height": height})

    @classmethod
    def load_last_selected_group(cls):
        data = cls._load(constants.LAST_SELECTED_GROUP_FILE, {})
        return data.get("last_selected", "")

    @classmethod
    def save_last_selected_group(cls, group_name):
        cls._save(constants.LAST_SELECTED_GROUP_FILE, {"last_selected": group_name})

    @classmethod
    def load_last_source_folder(cls):
        data = cls._load(constants.LAST_SOURCE_FOLDER_FILE, {})
        return data.get("path", "")

    @classmethod
    def save_last_source_folder(cls, path):
        cls._save(constants.LAST_SOURCE_FOLDER_FILE, {"path": path})

    @classmethod
    def load_last_extract_path(cls):
        data = cls._load(constants.LAST_EXTRACT_PATH_FILE, {})
        return data.get("path", "")

    @classmethod
    def save_last_extract_path(cls, path):
        cls._save(constants.LAST_EXTRACT_PATH_FILE, {"path": path})
```

## æ–‡ä»¶: app\data\__init__.py

```python
ï»¿# -*- coding: utf-8 -*-
```

## æ–‡ä»¶: app\ui\main_window.py

```python
# app/ui/main_window.py
import os
import time
from PySide6.QtCore import Qt, QSize
from PySide6.QtGui import QFont, QTextCursor, QTextCharFormat, QColor
from PySide6.QtWidgets import (
    QApplication, QWidget, QMainWindow, QLabel, QLineEdit, QPushButton,
    QTextEdit, QComboBox, QVBoxLayout, QHBoxLayout, QGridLayout,
    QFileDialog, QMessageBox, QFrame, QSizeGrip
)

from app.config import constants
from app.data.storage import JsonStorage
from app.core.file_manager import FileManager
from app.workers.extract_worker import ExtractThread
from app.workers.monitor_worker import MonitorThread
from app.workers.launcher_worker import LauncherThread
from app.ui.styles import get_stylesheet
from app.ui.title_bar import TitleBar
from app.ui.toast import Toast

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowSystemMenuHint | Qt.WindowMinimizeButtonHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        self._load_window_state()
        self.groups = JsonStorage.load_groups()
        self.last_selected_group = JsonStorage.load_last_selected_group()
        
        self.process_thread = None
        self.monitor_thread = None
        self.runner_thread = None

        self._init_ui()
        self.setWindowTitle("æ–‡ä»¶è¦†ç›–å·¥å…· - è‡ªåŠ¨è§£å‹ç‰ˆ")
        self.setStyleSheet(get_stylesheet())

        self.auto_process_on_startup()
        self.start_monitoring()

        # å¯åŠ¨æ—¶è‡ªåŠ¨åŠ è½½ä¸Šæ¬¡é€‰æ‹©çš„åˆ†ç»„
        self.load_group()

    def _load_window_state(self):
        self.setMinimumSize(QSize(780, 560))
        saved_size = JsonStorage.load_window_size()
        if saved_size and "width" in saved_size and "height" in saved_size:
            self.resize(saved_size["width"], saved_size["height"])
        else:
            self.resize(840, 600)

    def _init_ui(self):
        container = QWidget()
        container.setObjectName("MainContent")
        self.setCentralWidget(container)
        
        layout_container = QVBoxLayout(container)
        layout_container.setContentsMargins(0, 0, 0, 0)
        layout_container.setSpacing(0)

        self.title_bar = TitleBar(self)
        layout_container.addWidget(self.title_bar)

        content_widget = QWidget()
        layout_container.addWidget(content_widget, 1)

        self._build_content(content_widget)

        grip_layout = QHBoxLayout()
        grip_layout.setContentsMargins(0, 0, 0, 0)
        grip_layout.addStretch()
        grip = QSizeGrip(self)
        grip_layout.addWidget(grip)
        layout_container.addLayout(grip_layout)

    def _build_content(self, parent_widget):
        main_layout = QVBoxLayout(parent_widget)
        main_layout.setContentsMargins(12, 10, 12, 10)
        main_layout.setSpacing(8)

        header = QHBoxLayout()
        sub = QLabel("å®æ—¶ç›‘æ§ Â· æ™ºèƒ½è§£å‹ Â· é˜²é‡å¤å¤„ç†")
        sub.setProperty("role", "muted")
        header.addWidget(sub)
        header.addStretch()
        main_layout.addLayout(header)

        sep = QFrame()
        sep.setProperty("role", "sep")
        sep.setFixedHeight(1)
        main_layout.addWidget(sep)

        # --- è·¯å¾„è®¾ç½® (å…¨å®½) ---
        path_panel = QFrame()
        path_panel.setProperty("role", "panel")
        path_layout = QGridLayout(path_panel)
        path_layout.setColumnStretch(1, 1) # è®©ç¬¬äºŒåˆ— (è¾“å…¥æ¡†) è‡ªåŠ¨æ‹‰ä¼¸
        path_layout.addWidget(QLabel("è·¯å¾„è®¾ç½®"), 0, 0, 1, 3)
        
        self.edit_src = QLineEdit()
        self.edit_src.setReadOnly(True)
        self.edit_src.setText(JsonStorage.load_last_source_folder())
        self.edit_dst = QLineEdit()
        self.edit_main = QLineEdit()
        self.edit_main.setText(JsonStorage.load_main_program_path())
        self.edit_extract = QLineEdit()
        self.edit_extract.setText(JsonStorage.load_last_extract_path())

        # æ¥æºæ–‡ä»¶å¤¹è¡Œ (ç‰¹æ®Šå¤„ç†ï¼Œæœ‰ +/- æŒ‰é’®)
        lbl_src = QLabel("æ¥æºæ–‡ä»¶å¤¹")
        lbl_src.setAlignment(Qt.AlignRight)
        lbl_src.setProperty("role", "muted")
        
        src_btn_container = QWidget()
        src_btn_layout = QHBoxLayout(src_btn_container)
        src_btn_layout.setContentsMargins(0, 0, 0, 0)
        src_btn_layout.setSpacing(4)
        
        btn_font = QFont("Arial", 12, QFont.Bold)
        btn_prev = QPushButton("ï¼")
        btn_prev.setToolTip("ä¸Šä¸€ä¸ªç‰ˆæœ¬")
        btn_prev.setFixedSize(26, 26) 
        btn_prev.setFont(btn_font)
        btn_prev.clicked.connect(lambda: self.switch_source_version('prev'))
        
        btn_next = QPushButton("ï¼‹")
        btn_next.setToolTip("ä¸‹ä¸€ä¸ªç‰ˆæœ¬")
        btn_next.setFixedSize(26, 26)
        btn_next.setFont(btn_font)
        btn_next.clicked.connect(lambda: self.switch_source_version('next'))
        
        btn_src_browse = QPushButton("æµè§ˆ")
        btn_src_browse.setFixedWidth(50)
        btn_src_browse.clicked.connect(self.select_source)
        
        src_btn_layout.addWidget(btn_prev)
        src_btn_layout.addWidget(btn_next)
        src_btn_layout.addWidget(btn_src_browse)

        # æŒ‰ç…§ è§£å‹ -> æ¥æº -> ç›®æ ‡ -> ä¸»ç¨‹åº çš„æµç¨‹é¡ºåºæ’åˆ—
        self._add_path_row(path_layout, 1, "è§£å‹ç›®æ ‡æ–‡ä»¶å¤¹", self.edit_extract, self.select_extract_path)
        path_layout.addWidget(lbl_src, 2, 0)
        path_layout.addWidget(self.edit_src, 2, 1)
        path_layout.addWidget(src_btn_container, 2, 2)
        self._add_path_row(path_layout, 3, "ç›®æ ‡æ–‡ä»¶å¤¹", self.edit_dst, self.select_target)
        self._add_path_row(path_layout, 4, "ä¸»ç¨‹åºè·¯å¾„", self.edit_main, self.select_main_program)
        
        main_layout.addWidget(path_panel)

        # --- è·¯å¾„åˆ†ç»„ (å…¨å®½) ---
        group_panel = QFrame()
        group_panel.setProperty("role", "panel")
        grp_layout = QGridLayout(group_panel)
        grp_layout.setColumnStretch(1, 1)
        grp_layout.addWidget(QLabel("è·¯å¾„åˆ†ç»„"), 0, 0, 1, 3)
        
        self.edit_grp_name = QLineEdit()
        btn_save = QPushButton("ä¿å­˜åˆ†ç»„")
        btn_save.clicked.connect(self.save_group)
        
        self.combo_grp = QComboBox()
        btn_load = QPushButton("åŠ è½½")
        btn_load.clicked.connect(self.load_group)
        btn_del = QPushButton("Ã—")
        btn_del.setProperty("role", "danger")
        btn_del.setFixedWidth(30)
        btn_del.clicked.connect(self.delete_group)

        grp_layout.addWidget(QLabel("åˆ†ç»„åç§°"), 1, 0)
        grp_layout.addWidget(self.edit_grp_name, 1, 1)
        grp_layout.addWidget(btn_save, 1, 2)
        
        btn_container = QWidget()
        btn_box = QHBoxLayout(btn_container)
        btn_box.setContentsMargins(0,0,0,0)
        btn_box.setSpacing(4)
        btn_box.addWidget(btn_load)
        btn_box.addWidget(btn_del)
        
        grp_layout.addWidget(QLabel("é€‰æ‹©åˆ†ç»„"), 2, 0)
        grp_layout.addWidget(self.combo_grp, 2, 1)
        grp_layout.addWidget(btn_container, 2, 2)

        main_layout.addWidget(group_panel)
        
        self.refresh_group_list()

        # æ“ä½œæŒ‰é’®
        act_layout = QHBoxLayout()
        act_layout.addStretch()
        self.btn_start = QPushButton("å¼€å§‹è¦†ç›–")
        self.btn_start.setProperty("role", "primary")
        self.btn_start.setFixedWidth(140)
        self.btn_start.clicked.connect(self.start_copy)
        act_layout.addWidget(self.btn_start)
        main_layout.addLayout(act_layout)

        # æ—¥å¿—åŒº
        log_header = QHBoxLayout()
        lbl_log = QLabel("è¿è¡Œæ—¥å¿—")
        lbl_log.setProperty("role", "muted")
        log_header.addWidget(lbl_log)
        log_header.addStretch()
        
        btn_clear = QPushButton("æ¸…ç©ºæ—¥å¿—")
        btn_clear.clicked.connect(self.clear_log)
        btn_copy = QPushButton("å¤åˆ¶æ—¥å¿—")
        btn_copy.clicked.connect(self.copy_log)
        
        log_header.addWidget(btn_clear)
        log_header.addWidget(btn_copy)
        main_layout.addLayout(log_header)

        self.text_log = QTextEdit()
        self.text_log.setReadOnly(True)
        main_layout.addWidget(self.text_log, 1)

    def _add_path_row(self, layout, row, label, edit, slot):
        lbl = QLabel(label)
        lbl.setAlignment(Qt.AlignRight)
        lbl.setProperty("role", "muted")
        btn = QPushButton("æµè§ˆ")
        btn.setFixedWidth(70)
        btn.clicked.connect(slot)
        layout.addWidget(lbl, row, 0)
        layout.addWidget(edit, row, 1)
        layout.addWidget(btn, row, 2)

    # --- æ—¥å¿— ---
    def log(self, msg, is_error=False):
        cursor = self.text_log.textCursor()
        cursor.movePosition(QTextCursor.End)
        fmt = QTextCharFormat()
        if is_error:
            fmt.setBackground(QColor(constants.COLOR_ERROR_BG))
            fmt.setForeground(QColor(constants.COLOR_ERROR_FG))
            cursor.insertText(msg + "\n", fmt)
        else:
            cursor.insertText(msg + "\n")
        self.text_log.setTextCursor(cursor)
        self.text_log.ensureCursorVisible()

    def clear_log(self):
        self.text_log.clear()
    
    def copy_log(self):
        QApplication.clipboard().setText(self.text_log.toPlainText())

    # --- é€»è¾‘ ---
    def switch_source_version(self, direction):
        current = self.edit_src.text().strip()
        new_path = FileManager.get_adjacent_folder(current, direction)
        
        if new_path:
            self.edit_src.setText(new_path)
            JsonStorage.save_last_source_folder(new_path)
            dirname = os.path.basename(new_path)
            arrow = "ï¼‹" if direction == 'next' else "ï¼"
            self.log(f"{arrow} å·²åˆ‡æ¢è‡³: {dirname}")
        else:
            self.log("âš ï¸ æ— æ³•åˆ‡æ¢ (æ— æ›´å¤šç‰ˆæœ¬æˆ–è·¯å¾„æ— æ•ˆ)", True)

    def auto_process_on_startup(self):
        self.log("="*60)
        self.log("ç¨‹åºå¯åŠ¨ - å¼€å§‹è‡ªåŠ¨å¤„ç†")
        all_zips = FileManager.scan_zip_files(constants.DOWNLOAD_FOLDER)
        history = JsonStorage.load_history()
        
        valid_hist = [p for p in history if os.path.exists(p)]
        if len(history) != len(valid_hist):
            JsonStorage.save_history(valid_hist)
            history = valid_hist
        
        marked = 0
        for z in all_zips:
            if z not in history:
                history.append(z)
                marked += 1
                self.log(f"æ ‡è®°ç°æœ‰æ–‡ä»¶: {os.path.basename(z)}")
        
        if marked > 0:
            JsonStorage.save_history(history)
            
        self.log(f"å‘ç° {len(all_zips)} ä¸ªå‹ç¼©æ–‡ä»¶ï¼Œæ–°æ ‡è®° {marked} ä¸ª")
        self.log("="*60)

    def start_monitoring(self):
        self.monitor_thread = MonitorThread()
        self.monitor_thread.log_signal.connect(self.log)
        self.monitor_thread.new_file_detected.connect(self.on_new_file)
        self.monitor_thread.start()

    def on_new_file(self, new_files):
        extract_path = self.edit_extract.text().strip()
        if not extract_path or not os.path.isdir(extract_path):
            Toast.show_message(self, "è¯·å…ˆè®¾ç½®æœ‰æ•ˆçš„ç›®æ ‡è§£å‹æ–‡ä»¶å¤¹", is_error=True)
            self.log("âŒ é”™è¯¯: è§£å‹ç›®æ ‡æ–‡ä»¶å¤¹æ— æ•ˆæˆ–æœªè®¾ç½®", True)
            return

        self.process_thread = ExtractThread(new_files, extract_path)
        self.process_thread.log_signal.connect(self.log)
        self.process_thread.finished_signal.connect(self.on_extract_finished)
        self.process_thread.start()

    def on_extract_finished(self, path):
        if path:
            self.edit_src.setText(path)
            JsonStorage.save_last_source_folder(path)
            self.log(f"âœ… æ¥æºè·¯å¾„å·²è‡ªåŠ¨å¡«å……: {path}")
        self.log("="*60)

    def select_source(self):
        path = QFileDialog.getExistingDirectory(self, "é€‰æ‹©æ¥æºæ–‡ä»¶å¤¹")
        if path:
            self.edit_src.setText(path)
            JsonStorage.save_last_source_folder(path)

    def select_target(self):
        path = QFileDialog.getExistingDirectory(self, "é€‰æ‹©ç›®æ ‡æ–‡ä»¶å¤¹")
        if path: self.edit_dst.setText(path)

    def select_extract_path(self):
        path = QFileDialog.getExistingDirectory(self, "é€‰æ‹©è§£å‹ç›®æ ‡æ–‡ä»¶å¤¹")
        if path:
            self.edit_extract.setText(path)
            JsonStorage.save_last_extract_path(path)

    def select_main_program(self):
        path, _ = QFileDialog.getOpenFileName(self, "é€‰æ‹©ä¸»ç¨‹åº", "", "Executables (*.exe *.bat *.cmd *.py *.pyw);;All (*.*)")
        if path:
            self.edit_main.setText(path)
            JsonStorage.save_main_program_path(path)

    def save_group(self):
        name = self.edit_grp_name.text().strip()
        if not name:
            Toast.show_message(self, "è¯·è¾“å…¥åˆ†ç»„åç§°", is_error=True)
            return
        
        self.groups[name] = {
            "target": self.edit_dst.text().strip(),
            "main_program": self.edit_main.text().strip()
        }
        JsonStorage.save_groups(self.groups)
        self.refresh_group_list(name)
        
        self.log(f"ä¿å­˜åˆ†ç»„: {name}")
        Toast.show_message(self, f"åˆ†ç»„ '{name}' å·²ä¿å­˜")
        JsonStorage.save_last_selected_group(name)

    def load_group(self):
        name = self.combo_grp.currentText()
        if not name or name not in self.groups:
            return
        data = self.groups[name]
        self.edit_dst.setText(data.get("target", ""))
        self.edit_main.setText(data.get("main_program", ""))
        self.log(f"åŠ è½½åˆ†ç»„: {name}")
        Toast.show_message(self, f"å·²åŠ è½½åˆ†ç»„: {name}")
        JsonStorage.save_last_selected_group(name)

    def delete_group(self):
        name = self.combo_grp.currentText()
        if not name or name not in self.groups: return
        
        if QMessageBox.question(self, "ç¡®è®¤", f"åˆ é™¤åˆ†ç»„ '{name}'?", QMessageBox.Yes|QMessageBox.No) == QMessageBox.Yes:
            del self.groups[name]
            JsonStorage.save_groups(self.groups)
            self.refresh_group_list()
            self.log(f"å·²åˆ é™¤åˆ†ç»„: {name}")
            Toast.show_message(self, "åˆ†ç»„å·²åˆ é™¤")
            
            # åˆ é™¤åï¼Œé»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªæˆ–æ¸…ç©º
            new_selection = self.combo_grp.currentText()
            JsonStorage.save_last_selected_group(new_selection)

    def refresh_group_list(self, select_item=None):
        self.combo_grp.blockSignals(True)
        self.combo_grp.clear()
        self.combo_grp.addItems(list(self.groups.keys()))
        
        # ç¡®å®šè¦é€‰ä¸­çš„é¡¹
        item_to_select = select_item if select_item else self.last_selected_group
        
        idx = self.combo_grp.findText(item_to_select)
        if idx >= 0:
            self.combo_grp.setCurrentIndex(idx)
        elif self.combo_grp.count() > 0:
            self.combo_grp.setCurrentIndex(0)
        self.combo_grp.blockSignals(False)

    def start_copy(self):
        src = self.edit_src.text().strip()
        dst = self.edit_dst.text().strip()
        
        if not os.path.isdir(src) or not os.path.isdir(dst):
            Toast.show_message(self, "æ¥æºæˆ–ç›®æ ‡è·¯å¾„æ— æ•ˆ", is_error=True)
            return

        self.btn_start.setEnabled(False)
        self.btn_start.setText("æ‰§è¡Œä¸­...")
        QApplication.processEvents()
        
        # === æ ¸å¿ƒä¿®æ”¹ç‚¹ï¼šå…ˆæ€è¿›ç¨‹ï¼Œå†å¤åˆ¶ ===
        
        # 1. å…ˆæ£€æŸ¥å¹¶åœæ­¢æ­£åœ¨è¿è¡Œçš„æ—§ç¨‹åº
        if self.runner_thread and self.runner_thread.isRunning():
            self.log("âš ï¸ æ£€æµ‹åˆ°ç¨‹åºæ­£åœ¨è¿è¡Œï¼Œæ­£åœ¨å¼ºåˆ¶ç»ˆæ­¢ä»¥é‡Šæ”¾æ–‡ä»¶é”...")
            self.runner_thread.stop()
            self.runner_thread.wait() # å¿…é¡»ç­‰å¾…å®Œå…¨åœæ­¢
            time.sleep(0.2) # ç»™ç³»ç»Ÿä¸€ç‚¹æ—¶é—´é‡Šæ”¾å¥æŸ„
            self.log("âœ… æ—§ç¨‹åºå·²ç»ˆæ­¢")

        # 2. ç°åœ¨å®‰å…¨äº†ï¼Œå¼€å§‹è¦†ç›–æ–‡ä»¶
        self.log("\nå¼€å§‹è¦†ç›–...")
        count, errors = FileManager.copy_files_recursive(src, dst)
        
        for rel_path, err in errors:
            self.log(f"âŒ é”™è¯¯: {rel_path} - {err}", True)
        
        self.log(f"ä»»åŠ¡å®Œæˆï¼ŒæˆåŠŸ: {count}ï¼Œå¤±è´¥: {len(errors)}")
        
        if errors:
            Toast.show_message(self, f"è¦†ç›–æœ‰é”™è¯¯ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—", is_error=True)
        else:
            Toast.show_message(self, f"è¦†ç›–æˆåŠŸ (æ–‡ä»¶: {count})")
        
        # 3. å¯åŠ¨æ–°ç‰ˆç¨‹åº
        self.launch_program()
        
        self.btn_start.setEnabled(True)
        self.btn_start.setText("å¼€å§‹è¦†ç›–")

    def launch_program(self):
        path = self.edit_main.text().strip()
        if not path or not os.path.exists(path):
            self.log("âŒ ä¸»ç¨‹åºæ— æ•ˆæˆ–æœªè®¾ç½®", True)
            return
        
        # è¿™é‡Œè™½ç„¶ä¹Ÿæœ‰ stopï¼Œä½†å¦‚æœæ˜¯ç‚¹"å¼€å§‹è¦†ç›–"è¿›æ¥çš„ï¼Œä¸Šé¢å·²ç»stopè¿‡äº†ã€‚
        # è¿™é‡Œä¿ç•™æ˜¯ä¸ºäº†é˜²æ­¢ç›´æ¥è°ƒç”¨ launch_program çš„æƒ…å†µã€‚
        if self.runner_thread and self.runner_thread.isRunning():
            self.runner_thread.stop()
            self.runner_thread.wait()
            
        self.log("="*60)
        self.log(f"ğŸš€ å¯åŠ¨: {path}")
        self.runner_thread = LauncherThread(path)
        self.runner_thread.output_signal.connect(self.log)
        self.runner_thread.start()

    def closeEvent(self, event):
        if not self.isMaximized() and not self.isFullScreen():
            JsonStorage.save_window_size(self.width(), self.height())
            
        if self.monitor_thread: self.monitor_thread.stop()
        if self.runner_thread: self.runner_thread.stop()
        event.accept()
```

## æ–‡ä»¶: app\ui\styles.py

```python
ï»¿# app/ui/styles.py

def get_stylesheet():
    return """
        /* å…¨å±€èƒŒæ™¯ */
        QMainWindow, QWidget#MainContent {
            background-color: #1e1e1e;
            border: 1px solid #3f3f46;
        }
        
        /* ---------------- è‡ªå®šä¹‰æ ‡é¢˜æ æ ·å¼ ---------------- */
        QWidget#TitleBar {
            background-color: #252526;
            border-bottom: 1px solid #3f3f46;
        }
        QLabel#TitleLabel {
            color: #dcdcdc;
            font-family: "Microsoft YaHei";
            font-weight: bold;
            font-size: 10pt;
            padding-left: 5px;
        }
        /* æ ‡é¢˜æ æŒ‰é’®é€šç”¨æ ·å¼ */
        QPushButton.TitleBtn {
            background-color: transparent;
            color: #dcdcdc;
            border: none;
            font-family: "Segoe UI", "Microsoft YaHei";
            font-size: 10pt;
        }
        QPushButton.TitleBtn:hover {
            background-color: #3f3f46;
        }
        /* å…³é—­æŒ‰é’®ç‰¹ä¾‹ */
        QPushButton#BtnClose:hover {
            background-color: #c42b1c;
            color: white;
        }

        /* ----------------åŸæœ‰æ ·å¼ä¿æŒä¸å˜---------------- */
        QLabel {
            color: #dcdcdc;
            font-family: "Microsoft YaHei";
            font-size: 9pt;
        }
        QLabel[role="muted"] {
            color: #9e9e9e;
        }
        QLineEdit {
            background-color: #2d2d30;
            color: #dcdcdc;
            border: 1px solid #3f3f46;
            padding: 4px 6px;
            font-family: "Consolas";
            font-size: 9pt;
        }
        QLineEdit:focus {
            border: 1px solid #0e639c;
        }
        QComboBox {
            background-color: #2d2d30;
            color: #dcdcdc;
            border: 1px solid #3f3f46;
            padding: 2px 6px;
            font-family: "Microsoft YaHei";
            font-size: 9pt;
        }
        QComboBox QAbstractItemView {
            background-color: #2d2d30;
            color: #dcdcdc;
            selection-background-color: #3a3a3d;
            selection-color: #dcdcdc;
        }
        QPushButton {
            background-color: #3a3a3d;
            color: #dcdcdc;
            border: 1px solid #3f3f46;
            padding: 4px 10px;
            font-family: "Microsoft YaHei";
            font-size: 9pt;
        }
        QPushButton:hover {
            background-color: #454549;
        }
        QPushButton[role="primary"] {
            background-color: #0e639c;
            border-color: #0e639c;
            color: #ffffff;
            font-weight: bold;
        }
        QPushButton[role="primary"]:hover {
            background-color: #1177bb;
        }
        QPushButton[role="danger"] {
            background-color: #c53030;
            border-color: #c53030;
            color: #ffffff;
            font-weight: bold;
        }
        QPushButton[role="danger"]:hover {
            background-color: #b91c1c;
        }
        QTextEdit {
            background-color: #2d2d30;
            color: #dcdcdc;
            border: 1px solid #3f3f46;
            font-family: "Consolas";
            font-size: 9pt;
        }
        QFrame[role="panel"] {
            background-color: #252526;
            border: 1px solid #3f3f46;
        }
        QFrame[role="sep"] {
            background-color: #3f3f46;
        }
        QSizeGrip {
            background-color: transparent;
            width: 16px;
            height: 16px;
        }
    """
```

## æ–‡ä»¶: app\ui\title_bar.py

```python
# app/ui/title_bar.py
from PySide6.QtCore import Qt, QSize, QPoint
from PySide6.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton, QSpacerItem, QSizePolicy

class TitleBar(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("TitleBar")
        self.setFixedHeight(35)
        self.window_parent = parent
        self.start_pos = None
        self.is_moving = False

        self._init_ui()
        self.setWindowTitle(parent.windowTitle())

    def _init_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 0, 0, 0)
        layout.setSpacing(0)

        # æ ‡é¢˜æ–‡å­—
        self.lbl_title = QLabel()
        self.lbl_title.setObjectName("TitleLabel")
        layout.addWidget(self.lbl_title)

        layout.addSpacerItem(QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum))

        # æŒ‰é’®ç»„
        btn_size = QSize(46, 35)

        self.btn_min = QPushButton("â”€")
        self.btn_min.setFixedSize(btn_size)
        self.btn_min.setProperty("class", "TitleBtn") # ç”¨äº CSS é€‰æ‹©å™¨
        self.btn_min.clicked.connect(self.window_parent.showMinimized)

        self.btn_max = QPushButton("â–¡")
        self.btn_max.setFixedSize(btn_size)
        self.btn_max.setProperty("class", "TitleBtn")
        self.btn_max.clicked.connect(self._toggle_maximize)

        self.btn_close = QPushButton("âœ•")
        self.btn_close.setFixedSize(btn_size)
        self.btn_close.setObjectName("BtnClose") # ç‰¹æ®Šæ ·å¼
        self.btn_close.setProperty("class", "TitleBtn")
        self.btn_close.clicked.connect(self.window_parent.close)

        layout.addWidget(self.btn_min)
        layout.addWidget(self.btn_max)
        layout.addWidget(self.btn_close)
        
        # å¼ºåˆ¶è®¾ç½® class å±æ€§ä»¥åº”ç”¨æ ·å¼
        for btn in [self.btn_min, self.btn_max, self.btn_close]:
            btn.setAttribute(Qt.WA_StyledBackground)

    def setWindowTitle(self, title):
        self.lbl_title.setText(title)

    def changeEvent(self, event):
        if event.type() == event.Type.WindowTitleChange:
            self.setWindowTitle(self.window_parent.windowTitle())
        super().changeEvent(event)

    def _toggle_maximize(self):
        if self.window_parent.isMaximized():
            self.window_parent.showNormal()
            self.btn_max.setText("â–¡")
        else:
            self.window_parent.showMaximized()
            self.btn_max.setText("â")

    # --- æ‹–æ‹½é€»è¾‘ ---
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.is_moving = True
            self.start_pos = event.globalPosition().toPoint()

    def mouseMoveEvent(self, event):
        if self.is_moving and self.start_pos:
            delta = event.globalPosition().toPoint() - self.start_pos
            self.window_parent.move(self.window_parent.pos() + delta)
            self.start_pos = event.globalPosition().toPoint()

    def mouseReleaseEvent(self, event):
        self.is_moving = False

    def mouseDoubleClickEvent(self, event):
        if event.button() == Qt.LeftButton:
            self._toggle_maximize()
```

## æ–‡ä»¶: app\ui\toast.py

```python
ï»¿# app/ui/toast.py
from PySide6.QtCore import Qt, QTimer, QPropertyAnimation, QEasingCurve
from PySide6.QtWidgets import QLabel, QGraphicsOpacityEffect

class Toast(QLabel):
    @staticmethod
    def show_message(parent, text, is_error=False, duration=2000):
        """é™æ€æ–¹æ³•è°ƒç”¨æ˜¾ç¤º"""
        if not parent: return
        toast = Toast(parent, text, is_error)
        toast.show()
        # ä¿æŒå¼•ç”¨ä»¥å…è¢«åƒåœ¾å›æ”¶
        setattr(parent, "_current_toast", toast)
        QTimer.singleShot(duration, toast.fade_out)

    def __init__(self, parent, text, is_error=False):
        super().__init__(parent)
        self.setText(text)
        self.setAlignment(Qt.AlignCenter)
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.SubWindow | Qt.WindowStaysOnTopHint)
        self.setAttribute(Qt.WA_TransparentForMouseEvents)  # é¼ æ ‡ç©¿é€
        self.setAttribute(Qt.WA_DeleteOnClose)

        # æ ·å¼è®¾ç½®
        bg_color = "#c42b1c" if is_error else "#107c10"  # çº¢/ç»¿
        icon = "âŒ" if is_error else "âœ…"
        self.setText(f"{icon}  {text}")
        
        self.setStyleSheet(f"""
            QLabel {{
                background-color: {bg_color};
                color: white;
                font-family: "Microsoft YaHei";
                font-size: 14px;
                font-weight: bold;
                border-radius: 6px;
                padding: 10px 20px;
            }}
        """)
        
        self.adjustSize()
        self._center_on_parent(parent)
        
        # åŠ¨ç”»æ•ˆæœ
        self.opacity_effect = QGraphicsOpacityEffect(self)
        self.setGraphicsEffect(self.opacity_effect)
        self.opacity_effect.setOpacity(0)
        
        self.anim = QPropertyAnimation(self.opacity_effect, b"opacity")
        self.anim.setDuration(300)
        self.anim.setStartValue(0)
        self.anim.setEndValue(1)
        self.anim.setEasingCurve(QEasingCurve.OutCubic)
        self.anim.start()

    def _center_on_parent(self, parent):
        parent_geo = parent.geometry()
        # æ˜¾ç¤ºåœ¨åº•éƒ¨ä¸Šæ–¹ä¸€ç‚¹
        x = (parent_geo.width() - self.width()) // 2
        y = parent_geo.height() - self.height() - 80 
        self.move(x, y)

    def fade_out(self):
        self.anim.setDirection(QPropertyAnimation.Backward)
        self.anim.setDuration(500)
        self.anim.finished.connect(self.close)
        self.anim.start()
```

## æ–‡ä»¶: app\ui\__init__.py

```python
ï»¿# -*- coding: utf-8 -*-
```

## æ–‡ä»¶: app\workers\extract_worker.py

```python
# -*- coding: utf-8 -*-
# app/workers/extract_worker.py
import os
import shutil
from PySide6.QtCore import QThread, Signal
from app.config import constants
from app.core.file_manager import FileManager
from app.data.storage import JsonStorage

class ExtractThread(QThread):
    log_signal = Signal(str, bool)
    finished_signal = Signal(str)
    
    def __init__(self, new_files, extract_base_path):
        super().__init__()
        self.new_files = new_files
        self.extract_base_path = extract_base_path
    
    def run(self):
        if not self.new_files:
            return
        
        zip_path = self.new_files[0]
        zip_name = os.path.basename(zip_path)
        self.log_signal.emit(f"å‘ç°æ–°æ–‡ä»¶: {zip_name}", False)
        
        # å‡†å¤‡è·¯å¾„
        try:
            os.makedirs(self.extract_base_path, exist_ok=True)
            next_num = FileManager.get_next_jules_number(self.extract_base_path)
            new_folder_name = f"jules_{next_num}"
            new_folder_path = os.path.join(self.extract_base_path, new_folder_name)
            os.makedirs(new_folder_path, exist_ok=True)
            
            self.log_signal.emit(f"åˆ›å»ºæ–‡ä»¶å¤¹: {new_folder_name}", False)
            
            # å¤åˆ¶
            dest_zip = os.path.join(new_folder_path, zip_name)
            shutil.copy2(zip_path, dest_zip)
            self.log_signal.emit(f"å¤åˆ¶å‹ç¼©æ–‡ä»¶åˆ°: {new_folder_path}", False)
            
            # è§£å‹
            self.log_signal.emit("æ­£åœ¨è§£å‹...", False)
            success, result = FileManager.extract_zip(dest_zip, new_folder_path)
            
            if success:
                file_list = result
                self.log_signal.emit("âœ… è§£å‹å®Œæˆ", False)
                if file_list:
                    self.log_signal.emit(f"è§£å‹äº† {len(file_list)} ä¸ªæ–‡ä»¶:", False)
                    for filename in file_list:
                        self.log_signal.emit(f"  - {filename}", False)
                
                # æ¸…ç†
                try:
                    os.remove(dest_zip)
                    self.log_signal.emit(f"âœ… å·²åˆ é™¤å‹ç¼©æ–‡ä»¶: {zip_name}", False)
                except Exception as e:
                    self.log_signal.emit(f"âš ï¸ åˆ é™¤å‹ç¼©æ–‡ä»¶å¤±è´¥: {str(e)}", True)
                
                # è®°å½•å†å²
                history = JsonStorage.load_history()
                if zip_path not in history:
                    history.append(zip_path)
                    JsonStorage.save_history(history)
                
                self.finished_signal.emit(new_folder_path)
            else:
                self.log_signal.emit(f"âŒ è§£å‹å¤±è´¥: {result}", True)
                self.finished_signal.emit("")
                
        except Exception as e:
            self.log_signal.emit(f"âŒ å¤„ç†å¤±è´¥: {str(e)}", True)
            self.finished_signal.emit("")
```

## æ–‡ä»¶: app\workers\launcher_worker.py

```python
ï»¿# -*- coding: utf-8 -*-
# app/workers/launcher_worker.py
from PySide6.QtCore import QThread, Signal
from app.core.process_runner import ProcessRunner

class LauncherThread(QThread):
    output_signal = Signal(str)
    
    def __init__(self, program_path):
        super().__init__()
        self.program_path = program_path
        self.process = None
        self.running = True

    def run(self):
        try:
            cmd, work_dir = ProcessRunner.prepare_command(self.program_path)
            self.process = ProcessRunner.create_process(cmd, work_dir)

            if self.process.stdout:
                for line in self.process.stdout:
                    if not self.running:
                        break
                    self.output_signal.emit(line.strip())

            self.process.wait()
            self.output_signal.emit(f"ğŸ ä¸»ç¨‹åºå·²é€€å‡º (ä»£ç : {self.process.returncode})")

        except Exception as e:
            self.output_signal.emit(f"âŒ å¯åŠ¨/è¿è¡Œå‡ºé”™: {str(e)}")

    def stop(self):
        self.running = False
        if self.process:
            try:
                self.process.terminate()
            except:
                pass
```

## æ–‡ä»¶: app\workers\monitor_worker.py

```python
ï»¿# -*- coding: utf-8 -*-
# app/workers/monitor_worker.py
import os
import time
from PySide6.QtCore import QThread, Signal
from app.config import constants
from app.data.storage import JsonStorage
from app.core.file_manager import FileManager

class MonitorThread(QThread):
    new_file_detected = Signal(list)
    log_signal = Signal(str, bool)
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.known_files = set()
    
    def stop(self):
        self.running = False
    
    def run(self):
        self.log_signal.emit("ğŸ” å®æ—¶ç›‘æ§å·²å¯åŠ¨ï¼Œç­‰å¾…æ–°æ–‡ä»¶ä¸‹è½½...", False)
        
        history = JsonStorage.load_history()
        self.known_files = set(history)
        
        while self.running:
            try:
                current_files = FileManager.scan_zip_files(constants.DOWNLOAD_FOLDER)
                current_set = set(current_files)
                new_files = current_set - self.known_files
                
                if new_files:
                    new_list = list(new_files)
                    self.log_signal.emit(f"âš¡ æ£€æµ‹åˆ°æ–°ä¸‹è½½: {os.path.basename(new_list[0])}", False)
                    self.new_file_detected.emit(new_list)
                    self.known_files.update(new_files)
                
                time.sleep(2)
            except Exception as e:
                self.log_signal.emit(f"ç›‘æ§å¼‚å¸¸: {str(e)}", True)
                time.sleep(5)
```

## æ–‡ä»¶: app\workers\__init__.py

```python
ï»¿# -*- coding: utf-8 -*-
```

